crystal_doc_search_index_callback({"repository_name":"athena-dependency_injection","body":"# Dependency Injection\n\n[![CI](https://github.com/athena-framework/dependency-injection/workflows/CI/badge.svg)](https://github.com/athena-framework/dependency-injection/actions?query=workflow%3ACI)\n[![Latest release](https://img.shields.io/github/release/athena-framework/dependency-injection.svg)](https://github.com/athena-framework/dependency-injection/releases)\n\nRobust dependency injection service container framework.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n```yaml\ndependencies:\n  athena-dependency_injection:\n    github: athena-framework/dependency-injection\n    version: ~> 0.2.0\n```\n\n2. Run `shards install`\n\n## Documentation\n\nEverything is documented in the [API Docs](https://athena-framework.github.io/dependency-injection/Athena/DependencyInjection.html).\n\n## Contributing\n\n1. Fork it (https://github.com/athena-framework/dependency-injection/fork)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [George Dietrich](https://github.com/blacksmoke16) - creator and maintainer\n","program":{"html_id":"athena-dependency_injection/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"athena-dependency_injection","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"athena-dependency_injection/ACF","path":"ACF.html","kind":"alias","full_name":"ACF","name":"ACF","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/athena-config.cr","line_number":2,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L2"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":true,"aliased":"Athena::Config","aliased_html":"<a href=\"Athena/Config.html\">Athena::Config</a>","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Convenience alias to make referencing `Athena::Config` types easier.","summary":"<p>Convenience alias to make referencing <code><a href=\"Athena/Config.html\">Athena::Config</a></code> types easier.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/ACFA","path":"ACFA.html","kind":"alias","full_name":"ACFA","name":"ACFA","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/athena-config.cr","line_number":5,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L5"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":true,"aliased":"Athena::Config::Annotations","aliased_html":"<a href=\"Athena/Config/Annotations.html\">Athena::Config::Annotations</a>","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Convenience alias to make referencing `ACF::Annotations` types easier.","summary":"<p>Convenience alias to make referencing <code><a href=\"Athena/Config/Annotations.html\">ACF::Annotations</a></code> types easier.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/ADI","path":"ADI.html","kind":"alias","full_name":"ADI","name":"ADI","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/athena-dependency_injection.cr","line_number":14,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L14"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":true,"aliased":"Athena::DependencyInjection","aliased_html":"<a href=\"Athena/DependencyInjection.html\">Athena::DependencyInjection</a>","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Convenience alias to make referencing `Athena::DependencyInjection` types easier.","summary":"<p>Convenience alias to make referencing <code><a href=\"Athena/DependencyInjection.html\">Athena::DependencyInjection</a></code> types easier.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/ASPEC","path":"ASPEC.html","kind":"alias","full_name":"ASPEC","name":"ASPEC","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/athena-spec.cr","line_number":2,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/athena-spec.cr#L2"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":true,"aliased":"Athena::Spec","aliased_html":"<a href=\"Athena/Spec.html\">Athena::Spec</a>","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Convenience alias to make referencing `Athena::Spec` types easier.","summary":"<p>Convenience alias to make referencing <code><a href=\"Athena/Spec.html\">Athena::Spec</a></code> types easier.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena","path":"Athena.html","kind":"module","full_name":"Athena","name":"Athena","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/athena-config.cr","line_number":16,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L16"},{"filename":"lib/athena-spec/src/methods.cr","line_number":9,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/methods.cr#L9"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"ENV_NAME","name":"ENV_NAME","value":"\"ATHENA_ENV\"","doc":"The name of the environment variable used to determine Athena's current environment.","summary":"<p>The name of the environment variable used to determine Athena's current environment.</p>"}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"A web framework comprised of reusable, independent components.\n\nSee [Athena Framework](https://github.com/athena-framework) on Github.","summary":"<p>A web framework comprised of reusable, independent components.</p>","class_methods":[{"id":"environment:String-class-method","html_id":"environment:String-class-method","name":"environment","doc":"Returns the current environment Athena is in based on `ENV_NAME`.  Defaults to `development` if not defined.","summary":"<p>Returns the current environment Athena is in based on <code><a href=\"Athena.html#ENV_NAME\">ENV_NAME</a></code>.</p>","abstract":false,"args":[],"args_string":" : String","args_html":" : String","location":{"filename":"lib/athena-config/src/athena-config.cr","line_number":21,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L21"},"def":{"name":"environment","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"ENV[ENV_NAME]? || \"development\""}}],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"athena-dependency_injection/Athena/Config","path":"Athena/Config.html","kind":"module","full_name":"Athena::Config","name":"Config","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":1,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L1"},{"filename":"lib/athena-config/src/athena-config.cr","line_number":28,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L28"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena","kind":"module","full_name":"Athena","name":"Athena"},"doc":"Athena's Config component contains common types for configuring components/features, and managing `ACF::Parameters`.\n\nSee the [external documentation](https://athenaframework.org/components/config/) for more information.","summary":"<p>Athena's Config component contains common types for configuring components/features, and managing <code><a href=\"../Athena/Config/Parameters.html\">ACF::Parameters</a></code>.</p>","class_methods":[{"id":"config-class-method","html_id":"config-class-method","name":"config","doc":"Returns the configured `ACF::Base` instance.\nThe instance is a lazily initialized singleton.\n\n`ACF.load_configuration` may be redefined to change _how_ the configuration object is provided; e.g. create it from a `YAML` or `JSON` configuration file.\nSee the [external documentation](https://athenaframework.org/components/config/#configuration) for more information.","summary":"<p>Returns the configured <code><a href=\"../Athena/Config/Base.html\">ACF::Base</a></code> instance.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"lib/athena-config/src/athena-config.cr","line_number":73,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L73"},"def":{"name":"config","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (value = @@config).nil?\n  @@config = (ACF.load_configuration)\nelse\n  value\nend"}},{"id":"parameters-class-method","html_id":"parameters-class-method","name":"parameters","doc":"Returns the configured `ACF::Parameters` instance.\nThe instance is a lazily initialized singleton.\n\n`ACF.load_parameters` may be redefined to change _how_ the parameters object is provided; e.g. create it from a `YAML` or `JSON` configuration file.\nSee the [external documentation](https://athenaframework.org/components/config/#parameters) for more information.","summary":"<p>Returns the configured <code><a href=\"../Athena/Config/Parameters.html\">ACF::Parameters</a></code> instance.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"lib/athena-config/src/athena-config.cr","line_number":80,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L80"},"def":{"name":"parameters","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (value = @@parameters).nil?\n  @@parameters = (ACF.load_parameters)\nelse\n  value\nend"}}],"constructors":[],"instance_methods":[],"macros":[{"id":"configuration_annotation(name,*args,&)-macro","html_id":"configuration_annotation(name,*args,&amp;)-macro","name":"configuration_annotation","doc":"Registers a configuration annotation with the provided *name*.\nDefines a configuration record with the provided *args*, if any, that represents the possible arguments that the annotation accepts.\nMay also be used with a block to add custom methods to the configuration record.\n\n### Example\n\n```\n# Defines an annotation without any arguments.\nACF.configuration_annotation Secure\n\n# Defines annotation with a required and optional argument.\n# The default value will be used if that key isn't supplied in the annotation.\nACF.configuration_annotation SomeAnn, id : Int32, debug : Bool = true\n\n# A block can be used to define custom methods on the configuration object.\nACF.configuration_annotation CustomAnn, first_name : String, last_name : String do\n  def name : String\n    \"#{@first_name} #{@last_name}\"\n  end\nend\n```\n\nNOTE: The logic to actually do the resolution of the annotations must be handled in the owning shard.\n`Athena::Config` only defines the common logic that each implementation can use.\nSee `ACF::AnnotationConfigurations` for more information.","summary":"<p>Registers a configuration annotation with the provided <em>name</em>.</p>","abstract":false,"args":[{"name":"name","doc":null,"default_value":"","external_name":"name","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(name, *args, &)","location":{"filename":"lib/athena-config/src/athena-config.cr","line_number":57,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/athena-config.cr#L57"},"def":{"name":"configuration_annotation","args":[{"name":"name","doc":null,"default_value":"","external_name":"name","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"block_arg":{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},"visibility":"Public","body":"      annotation \n{{ name.id }}\n; \nend\n\n      \n# :nodoc:\n\n      record \n{{ name.id }}\nConfiguration < ACF::AnnotationConfigurations::ConfigurationBase\n{% if args.empty? %}{% else %}, {{ *args }}{% end %}\n do\n        \n{{ yield }}\n\n      \nend\n\n      \n{% CUSTOM_ANNOTATIONS << name %}\n\n    \n"}}],"types":[{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations","path":"Athena/Config/AnnotationConfigurations.html","kind":"struct","full_name":"Athena::Config::AnnotationConfigurations","name":"AnnotationConfigurations","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"athena-dependency_injection/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":37,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L37"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config","kind":"module","full_name":"Athena::Config","name":"Config"},"doc":"Wraps a hash of configuration annotations applied to a given type, method, or instance variable.\nProvides the logic to access each annotation's configuration in a type safe manner.\n\nImplementations using this type must define the logic to provide the annotation hash manually;\nthis would most likely just be something like:\n\n```\n# Define a hash to store the configurations.\n{% custom_configurations = {} of Nil => Nil %}\n\n# Iterate over the stored annotation classes.\n{% for ann_class in ACF::CUSTOM_ANNOTATIONS %}\n   {% ann_class = ann_class.resolve %}\n\n   # Define an array to store the annotation configurations of this type.\n   {% annotations = [] of Nil %}\n\n   # Iterate over each annotation of this type on the given type, method, or instance variable.\n   {% for ann in type_method_instance_variable.annotations ann_class %}\n     # Add a new instance of the annotations configuration to the array.\n     # Add the annotation's positional arguments first, if any, then named arguments.\n     {% annotations << \"#{ann_class}Configuration.new(#{ann.args.empty? ? \"\".id : \"#{ann.args.splat},\".id}#{ann.named_args.double_splat})\".id %}\n   {% end %}\n\n   # Update the configuration hash with the annotation class and configuration objects, but only if there was at least one.\n   {% custom_configurations[ann_class] = \"(#{annotations} of ACF::AnnotationConfigurations::ConfigurationBase)\".id unless annotations.empty? %}\n {% end %}\n\n# ...\n\n# Use the built hash to instantiate a new `ACF::AnnotationConfigurations` instance.\nACF::AnnotationConfigurations.new({{custom_configurations}} of ACF::AnnotationConfigurations::Classes => Array(ACF::AnnotationConfigurations::ConfigurationBase)),\n```\n\nTODO: Centralize the hash resolution logic once [this issue](https://github.com/crystal-lang/crystal/issues/8835) is resolved.","summary":"<p>Wraps a hash of configuration annotations applied to a given type, method, or instance variable.</p>","class_methods":[],"constructors":[{"id":"new(annotation_hash:AnnotationHash=AnnotationHash.new)-class-method","html_id":"new(annotation_hash:AnnotationHash=AnnotationHash.new)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"annotation_hash","doc":null,"default_value":"AnnotationHash.new","external_name":"annotation_hash","restriction":"AnnotationHash"}],"args_string":"(annotation_hash : AnnotationHash = <span class=\"t\">AnnotationHash</span>.<span class=\"k\">new</span>)","args_html":"(annotation_hash : <a href=\"../../Athena/Config/AnnotationConfigurations/AnnotationHash.html\">AnnotationHash</a> = <span class=\"t\">AnnotationHash</span>.<span class=\"k\">new</span>)","location":{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":46,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L46"},"def":{"name":"new","args":[{"name":"annotation_hash","doc":null,"default_value":"AnnotationHash.new","external_name":"annotation_hash","restriction":"AnnotationHash"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(annotation_hash)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"has?(ann_class:ACF::AnnotationConfigurations::Classes):Bool-instance-method","html_id":"has?(ann_class:ACF::AnnotationConfigurations::Classes):Bool-instance-method","name":"has?","doc":"Returns `true` if there are annotations of the provided *ann_class*, otherwise `false`.","summary":"<p>Returns <code>true</code> if there are annotations of the provided <em>ann_class</em>, otherwise <code>false</code>.</p>","abstract":false,"args":[{"name":"ann_class","doc":null,"default_value":"","external_name":"ann_class","restriction":"ACF::AnnotationConfigurations::Classes"}],"args_string":"(ann_class : ACF::AnnotationConfigurations::Classes) : Bool","args_html":"(ann_class : <a href=\"../../Athena/Config/AnnotationConfigurations/Classes.html\">ACF::AnnotationConfigurations::Classes</a>) : Bool","location":{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":46,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L46"},"def":{"name":"has?","args":[{"name":"ann_class","doc":null,"default_value":"","external_name":"ann_class","restriction":"ACF::AnnotationConfigurations::Classes"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Bool","visibility":"Public","body":"@annotation_hash.has_key?(ann_class)"}}],"macros":[],"types":[{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations/AnnotationHash","path":"Athena/Config/AnnotationConfigurations/AnnotationHash.html","kind":"alias","full_name":"Athena::Config::AnnotationConfigurations::AnnotationHash","name":"AnnotationHash","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":46,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L46"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":true,"aliased":"Hash(Athena::Config::AnnotationConfigurations::Placeholder.class, Array(Athena::Config::AnnotationConfigurations::ConfigurationBase))","aliased_html":"Hash(Athena::Config::AnnotationConfigurations::Placeholder.class, Array(<a href=\"../../../Athena/Config/AnnotationConfigurations/ConfigurationBase.html\">Athena::Config::AnnotationConfigurations::ConfigurationBase</a>))","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations","kind":"struct","full_name":"Athena::Config::AnnotationConfigurations","name":"AnnotationConfigurations"},"doc":"The Hash type that will store the annotation configurations.","summary":"<p>The Hash type that will store the annotation configurations.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations/Classes","path":"Athena/Config/AnnotationConfigurations/Classes.html","kind":"alias","full_name":"Athena::Config::AnnotationConfigurations::Classes","name":"Classes","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":46,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L46"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":true,"aliased":"Athena::Config::AnnotationConfigurations::Placeholder.class","aliased_html":"Athena::Config::AnnotationConfigurations::Placeholder.class","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations","kind":"struct","full_name":"Athena::Config::AnnotationConfigurations","name":"AnnotationConfigurations"},"doc":"A union representing the possible annotation classes that could be applied to a type, method, or instance variable.","summary":"<p>A union representing the possible annotation classes that could be applied to a type, method, or instance variable.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations/ConfigurationBase","path":"Athena/Config/AnnotationConfigurations/ConfigurationBase.html","kind":"struct","full_name":"Athena::Config::AnnotationConfigurations::ConfigurationBase","name":"ConfigurationBase","abstract":true,"superclass":{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"athena-dependency_injection/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":39,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L39"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config/AnnotationConfigurations","kind":"struct","full_name":"Athena::Config::AnnotationConfigurations","name":"AnnotationConfigurations"},"doc":"Base type of annotation configuration objects registered via `Athena::Config.configuration_annotation`.","summary":"<p>Base type of annotation configuration objects registered via <code><a href=\"../../../Athena/Config.html#configuration_annotation(name,*args,&)-macro\">Athena::Config.configuration_annotation</a></code>.</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"lib/athena-config/src/annotation_configurations.cr","line_number":39,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotation_configurations.cr#L39"},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"athena-dependency_injection/Athena/Config/Annotations","path":"Athena/Config/Annotations.html","kind":"module","full_name":"Athena::Config::Annotations","name":"Annotations","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/annotations.cr","line_number":1,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotations.cr#L1"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config","kind":"module","full_name":"Athena::Config","name":"Config"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"athena-dependency_injection/Athena/Config/Annotations/Resolvable","path":"Athena/Config/Annotations/Resolvable.html","kind":"annotation","full_name":"Athena::Config::Annotations::Resolvable","name":"Resolvable","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/annotations.cr","line_number":25,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/annotations.cr#L25"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config/Annotations","kind":"module","full_name":"Athena::Config::Annotations","name":"Annotations"},"doc":"Can be applied to a type included within `ACF::Base` to allow it to be resolvable via an `ACF::ConfigurationResolverInterface`.\nThe annotation should be provided a \"path\", either as the first positional argument, or via the `path` field, to the object from the `ACF::Base` instance.\n\n```\n@[ACFA::Resolvable(path: \"some_config.nested_config\")]\nstruct OtherConfig\n  getter other_config_option : String = \"OTHER_OPTION\"\nend\n\n@[ACFA::Resolvable(\"some_config\")]\nstruct SomeConfig\n  getter some_config_option : String = \"OPTION\"\n  getter nested_config : OtherConfig = OtherConfig.new\nend\n\n# Reopen ACF::Base to add our custom configuration type.\nclass Athena::Config::Base\n  getter some_config : SomeConfig = SomeConfig.new\nend\n\nACF::ConfigurationResolver.new.resolve(SomeConfig).some_config_option   # => OPTION\nACF::ConfigurationResolver.new.resolve(OtherConfig).other_config_option # => OTHER_OPTION\n```","summary":"<p>Can be applied to a type included within <code><a href=\"../../../Athena/Config/Base.html\">ACF::Base</a></code> to allow it to be resolvable via an <code><a href=\"../../../Athena/Config/ConfigurationResolverInterface.html\">ACF::ConfigurationResolverInterface</a></code>.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"athena-dependency_injection/Athena/Config/Base","path":"Athena/Config/Base.html","kind":"class","full_name":"Athena::Config::Base","name":"Base","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/athena-config/src/base.cr","line_number":4,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/base.cr#L4"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config","kind":"module","full_name":"Athena::Config","name":"Config"},"doc":"The base type representing how various Athena components/features are configured.\n\nSee `Athena::Config.config`.","summary":"<p>The base type representing how various Athena components/features are configured.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Config/ConfigurationResolver","path":"Athena/Config/ConfigurationResolver.html","kind":"struct","full_name":"Athena::Config::ConfigurationResolver","name":"ConfigurationResolver","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"athena-dependency_injection/Athena/Config/ConfigurationResolverInterface","kind":"module","full_name":"Athena::Config::ConfigurationResolverInterface","name":"ConfigurationResolverInterface"},{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"athena-dependency_injection/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":15,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L15"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[{"html_id":"athena-dependency_injection/Athena/Config/ConfigurationResolverInterface","kind":"module","full_name":"Athena::Config::ConfigurationResolverInterface","name":"ConfigurationResolverInterface"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config","kind":"module","full_name":"Athena::Config","name":"Config"},"doc":"See `Athena::Config::ConfigurationResolverInterface`.","summary":"<p>See <code><a href=\"../../Athena/Config/ConfigurationResolverInterface.html\">Athena::Config::ConfigurationResolverInterface</a></code>.</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":15,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L15"},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"id":"resolve(_type:_)-instance-method","html_id":"resolve(_type:_)-instance-method","name":"resolve","doc":"Resolves the configuration object for the given *_type*.\n\nRaises a `NotImplementedError` if no `#resolve` method exists for the given *_type*.","summary":"<p>Resolves the configuration object for the given <em>_type</em>.</p>","abstract":false,"args":[{"name":"_type","doc":null,"default_value":"","external_name":"_type","restriction":"_"}],"args_string":"(_type : _)","args_html":"(_type : _)","location":{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":34,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L34"},"def":{"name":"resolve","args":[{"name":"_type","doc":null,"default_value":"","external_name":"_type","restriction":"_"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"raise(NotImplementedError.new(\"Unable to resolve configuration for type '#{_type}'.\"))"}},{"id":"resolve:ACF::Base-instance-method","html_id":"resolve:ACF::Base-instance-method","name":"resolve","doc":"Returns the `ACF::Base` configuration object.","summary":"<p>Returns the <code><a href=\"../../Athena/Config/Base.html\">ACF::Base</a></code> configuration object.</p>","abstract":false,"args":[],"args_string":" : ACF::Base","args_html":" : <a href=\"../../Athena/Config/Base.html\">ACF::Base</a>","location":{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":39,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L39"},"def":{"name":"resolve","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"ACF::Base","visibility":"Public","body":"base"}}],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Config/ConfigurationResolverInterface","path":"Athena/Config/ConfigurationResolverInterface.html","kind":"module","full_name":"Athena::Config::ConfigurationResolverInterface","name":"ConfigurationResolverInterface","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":4,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L4"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[{"html_id":"athena-dependency_injection/Athena/Config/ConfigurationResolver","kind":"struct","full_name":"Athena::Config::ConfigurationResolver","name":"ConfigurationResolver"}],"namespace":{"html_id":"athena-dependency_injection/Athena/Config","kind":"module","full_name":"Athena::Config","name":"Config"},"doc":"A type that allows resolving a specific configuration object by type.\nThe main usecase for this type is to abstract _how_ a configuration object is provided; making testing/future refactors easier.\nSee `ACFA::Resolvable` for details.","summary":"<p>A type that allows resolving a specific configuration object by type.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"resolve(_type:_)-instance-method","html_id":"resolve(_type:_)-instance-method","name":"resolve","doc":"Resolves the configuration object for the given *_type*.\n\nRaises a `NotImplementedError` if no `#resolve` method exists for the given *_type*.","summary":"<p>Resolves the configuration object for the given <em>_type</em>.</p>","abstract":true,"args":[{"name":"_type","doc":null,"default_value":"","external_name":"_type","restriction":"_"}],"args_string":"(_type : _)","args_html":"(_type : _)","location":{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":11,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L11"},"def":{"name":"resolve","args":[{"name":"_type","doc":null,"default_value":"","external_name":"_type","restriction":"_"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"resolve:ACF::Base-instance-method","html_id":"resolve:ACF::Base-instance-method","name":"resolve","doc":"Returns the `ACF::Base` configuration object.","summary":"<p>Returns the <code><a href=\"../../Athena/Config/Base.html\">ACF::Base</a></code> configuration object.</p>","abstract":true,"args":[],"args_string":" : ACF::Base","args_html":" : <a href=\"../../Athena/Config/Base.html\">ACF::Base</a>","location":{"filename":"lib/athena-config/src/configuration_resolver.cr","line_number":6,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/configuration_resolver.cr#L6"},"def":{"name":"resolve","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"ACF::Base","visibility":"Public","body":""}}],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Config/Parameters","path":"Athena/Config/Parameters.html","kind":"class","full_name":"Athena::Config::Parameters","name":"Parameters","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/athena-config/src/parameters.cr","line_number":4,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-config/src/parameters.cr#L4"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Config","kind":"module","full_name":"Athena::Config","name":"Config"},"doc":"The base type containing various reusable configuration values, i.e. parameters.\n\nSee `Athena::Config.parameters`.","summary":"<p>The base type containing various reusable configuration values, i.e.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"athena-dependency_injection/Athena/DependencyInjection","path":"Athena/DependencyInjection.html","kind":"module","full_name":"Athena::DependencyInjection","name":"DependencyInjection","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/athena-dependency_injection.cr","line_number":27,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L27"},{"filename":"src/proxy.cr","line_number":3,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L3"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena","kind":"module","full_name":"Athena","name":"Athena"},"doc":"Athena's Dependency Injection (DI) component, `ADI` for short, adds a service container layer to your project.  This allows useful objects, aka services, to be shared throughout the project.\nThese objects live in a special class called the `ADI::ServiceContainer` (SC).\n\nThe SC is lazily initialized on fibers; this allows the SC to be accessed anywhere within the project.  The `Athena::DependencyInjection.container` method will return the SC for the current fiber.\nSince the SC is defined on fibers, it allows for each fiber to have its own SC instance.  This can be useful for web frameworks as each request would have its own SC scoped to that request.\n\n* See `ADI::Register` for documentation on registering services.\n\nNOTE: It is highly recommended to use interfaces as opposed to concrete types when defining the initializers for both services and non-services.\nUsing interfaces allows changing the functionality of a type by just changing what service gets injected into it, such as via an alias.\nSee this [blog post](https://dev.to/blacksmoke16/dependency-injection-in-crystal-2d66#plug-and-play) for an example of this.","summary":"<p>Athena's Dependency Injection (DI) component, <code><a href=\"../ADI.html\">ADI</a></code> for short, adds a service container layer to your project.</p>","class_methods":[{"id":"container:ADI::ServiceContainer-class-method","html_id":"container:ADI::ServiceContainer-class-method","name":"container","doc":"Returns the `ADI::ServiceContainer` for the current fiber.","summary":"<p>Returns the <code><a href=\"../Athena/DependencyInjection/ServiceContainer.html\">ADI::ServiceContainer</a></code> for the current fiber.</p>","abstract":false,"args":[],"args_string":" : ADI::ServiceContainer","args_html":" : <a href=\"../Athena/DependencyInjection/ServiceContainer.html\">ADI::ServiceContainer</a>","location":{"filename":"src/athena-dependency_injection.cr","line_number":609,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L609"},"def":{"name":"container","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"ADI::ServiceContainer","visibility":"Public","body":"Fiber.current.container"}}],"constructors":[],"instance_methods":[],"macros":[{"id":"auto_configure(type,options)-macro","html_id":"auto_configure(type,options)-macro","name":"auto_configure","doc":"Applies the provided *options* to any registered service of the provided *type*.\n\nA common use case of this would be to apply a specific tag to all instances of an interface; thus preventing the need to manually apply the tag for each implementation.\nThis can be paired with `Athena::DependencyInjection.bind` to make working with tags easier.\n\n### Example\n\n```\nmodule ConfigInterface; end\n\n# Automatically apply the `\"config\"` tag to all instances of `ConfigInterface`.\nADI.auto_configure ConfigInterface, {tags: [\"config\"]}\n\n@[ADI::Register]\nrecord ConfigOne do\n  include ConfigInterface\nend\n\n@[ADI::Register]\nrecord ConfigTwo do\n  include ConfigInterface\nend\n\n# Options supplied on the annotation itself override the auto configured options.\n@[ADI::Register(tags: [] of String)]\nrecord ConfigThree do\n  include ConfigInterface\nend\n\n@[ADI::Register(_configs: \"!config\", public: true)]\nrecord ConfigClient, configs : Array(ConfigInterface)\n\nADI.container.config_client.configs # => [ConfigOne(), ConfigTwo()]\n```","summary":"<p>Applies the provided <em>options</em> to any registered service of the provided <em>type</em>.</p>","abstract":false,"args":[{"name":"type","doc":null,"default_value":"","external_name":"type","restriction":""},{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""}],"args_string":"(type, options)","location":{"filename":"src/athena-dependency_injection.cr","line_number":65,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L65"},"def":{"name":"auto_configure","args":[{"name":"type","doc":null,"default_value":"","external_name":"type","restriction":""},{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    \n{% AUTO_CONFIGURATIONS[type.resolve] = options %}\n\n  \n"}},{"id":"bind(key,value)-macro","html_id":"bind(key,value)-macro","name":"bind","doc":"Allows binding a *value* to a *key* in order to enable auto registration of that value.\n\nBindings allow scalar values, or those that could not otherwise be handled via [service aliases](./DependencyInjection/Register.html#aliasing-services), to be auto registered.\nThis allows those arguments to be defined once and reused, as opposed to using named arguments to manually specify them for each service.\n\nBindings can also be declared with a type restriction to allow taking the type restriction of the argument into account.\nTyped bindings are always checked first as the most specific type is always preferred.\nIf no typed bindings match the argument's type, then the last defined untyped bindings is used.\n\n### Example\n\n```\nmodule ValueInterface; end\n\n@[ADI::Register(_value: 1, name: \"value_one\")]\n@[ADI::Register(_value: 2, name: \"value_two\")]\n@[ADI::Register(_value: 3, name: \"value_three\")]\nrecord ValueService, value : Int32 do\n  include ValueInterface\nend\n\n# Untyped bindings\nADI.bind api_key, ENV[\"API_KEY\"]\nADI.bind config, {id: 12_i64, active: true}\nADI.bind static_value, 123\nADI.bind odd_values, [\"@value_one\", \"@value_three\"]\nADI.bind value_arr, [true, true, false]\n\n# Typed bindings\nADI.bind value_arr : Array(Int32), [1, 2, 3]\nADI.bind value_arr : Array(Float64), [1.0, 2.0, 3.0]\n\n@[ADI::Register(public: true)]\nrecord BindingClient,\n  api_key : String,\n  config : NamedTuple(id: Int64, active: Bool),\n  static_value : Int32,\n  odd_values : Array(ValueInterface)\n\n@[ADI::Register(public: true)]\nrecord IntArr, value_arr : Array(Int32)\n\n@[ADI::Register(public: true)]\nrecord FloatArr, value_arr : Array(Float64)\n\n@[ADI::Register(public: true)]\nrecord BoolArr, value_arr : Array(Bool)\n\nADI.container.binding_client # =>\n# BindingClient(\n#  @api_key=\"123ABC\",\n#  @config={id: 12, active: true},\n#  @static_value=123,\n#  @odd_values=[ValueService(@value=1), ValueService(@value=3)])\n\nADI.container.int_arr   # => IntArr(@value_arr=[1, 2, 3])\nADI.container.float_arr # => FloatArr(@value_arr=[1.0, 2.0, 3.0])\nADI.container.bool_arr  # => BoolArr(@value_arr=[true, true, false])\n```","summary":"<p>Allows binding a <em>value</em> to a <em>key</em> in order to enable auto registration of that value.</p>","abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(key, value)","location":{"filename":"src/athena-dependency_injection.cr","line_number":128,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L128"},"def":{"name":"bind","args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    \n{% if key.is_a?(TypeDeclaration) %}\n      {% name = key.var.id.stringify %}\n      {% type = key.type.resolve %}\n    {% else %}\n      {% name = key.id.stringify %}\n      {% type = Crystal::Macros::Nop %}\n    {% end %}\n\n\n    \n# TODO: Refactor this to ||= once https://github.com/crystal-lang/crystal/pull/9409 is released\n\n    \n{% if BINDINGS[name] == nil\n  BINDINGS[name] = {typed: [] of Nil, untyped: [] of Nil}\nend %}\n\n\n    \n{% if type == Crystal::Macros::Nop %}\n      {% BINDINGS[name][:untyped].unshift({value: value, type: type}) %}\n    {% else %}\n      {% BINDINGS[name][:typed].unshift({value: value, type: type}) %}\n    {% end %}\n\n  \n"}}],"types":[{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Inject","path":"Athena/DependencyInjection/Inject.html","kind":"annotation","full_name":"Athena::DependencyInjection::Inject","name":"Inject","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/athena-dependency_injection.cr","line_number":606,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L606"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/DependencyInjection","kind":"module","full_name":"Athena::DependencyInjection","name":"DependencyInjection"},"doc":"Specifies which constructor should be used for injection.\n\n```\n@[ADI::Register(_value: 2, public: true)]\nclass SomeService\n  @active : Bool = false\n\n  def initialize(value : String, @active : Bool)\n    @value = value.to_i\n  end\n\n  @[ADI::Inject]\n  def initialize(@value : Int32); end\nend\n\nADI.container.some_service # => #<SomeService:0x7f51a77b1eb0 @active=false, @value=2>\nSomeService.new \"1\", true  # => #<SomeService:0x7f51a77b1e90 @active=true, @value=1>\n```\n\nWithout the `ADI::Inject` annotation, the first initializer would be used, which would fail since we are not providing a value for the `active` argument.\n`ADI::Inject` allows telling the service container that it should use the second constructor when registering this service.  This allows a constructor overload\nspecific to DI to be used while still allowing the type to be used outside of DI via other constructors.","summary":"<p>Specifies which constructor should be used for injection.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Proxy","path":"Athena/DependencyInjection/Proxy.html","kind":"struct","full_name":"Athena::DependencyInjection::Proxy(O)","name":"Proxy","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"athena-dependency_injection/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/proxy.cr","line_number":3,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L3"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/DependencyInjection","kind":"module","full_name":"Athena::DependencyInjection","name":"DependencyInjection"},"doc":"Represents a lazily initialized service.\nSee the \"Service Proxies\" section within `ADI::Register`.","summary":"<p>Represents a lazily initialized service.</p>","class_methods":[],"constructors":[{"id":"new(service_id:String,loader:Proc(O))-class-method","html_id":"new(service_id:String,loader:Proc(O))-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"service_id","doc":null,"default_value":"","external_name":"service_id","restriction":"String"},{"name":"loader","doc":null,"default_value":"","external_name":"loader","restriction":"Proc(O)"}],"args_string":"(service_id : String, loader : Proc(O))","args_html":"(service_id : String, loader : Proc(O))","location":{"filename":"src/proxy.cr","line_number":18,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L18"},"def":{"name":"new","args":[{"name":"service_id","doc":null,"default_value":"","external_name":"service_id","restriction":"String"},{"name":"loader","doc":null,"default_value":"","external_name":"loader","restriction":"Proc(O)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Proxy(O).allocate\n_.initialize(service_id, loader)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"instance-instance-method","html_id":"instance-instance-method","name":"instance","doc":"Returns proxied service `O`; instantiating it if it has not already been.","summary":"<p>Returns proxied service <code>O</code>; instantiating it if it has not already been.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/proxy.cr","line_number":10,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L10"},"def":{"name":"instance","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (value = @instance).nil?\n  @instance = (begin\n    @instantiated = true\n    @loader.call\n  end)\nelse\n  value\nend"}},{"id":"instantiated?:Bool-instance-method","html_id":"instantiated?:Bool-instance-method","name":"instantiated?","doc":"Returns whether the proxied service has been instantiated yet.","summary":"<p>Returns whether the proxied service has been instantiated yet.</p>","abstract":false,"args":[],"args_string":" : Bool","args_html":" : Bool","location":{"filename":"src/proxy.cr","line_number":16,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L16"},"def":{"name":"instantiated?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Bool","visibility":"Public","body":"@instantiated"}},{"id":"service_id:String-instance-method","html_id":"service_id:String-instance-method","name":"service_id","doc":"Returns the service ID (name) of the proxied service.","summary":"<p>Returns the service ID (name) of the proxied service.</p>","abstract":false,"args":[],"args_string":" : String","args_html":" : String","location":{"filename":"src/proxy.cr","line_number":13,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L13"},"def":{"name":"service_id","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"@service_id"}},{"id":"service_type:O.class-instance-method","html_id":"service_type:O.class-instance-method","name":"service_type","doc":"Returns the type of the proxied service.","summary":"<p>Returns the type of the proxied service.</p>","abstract":false,"args":[],"args_string":" : <span class=\"t\">O</span>.<span class=\"k\">class</span>","args_html":" : <span class=\"t\">O</span>.<span class=\"k\">class</span>","location":{"filename":"src/proxy.cr","line_number":21,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L21"},"def":{"name":"service_type","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"O.class","visibility":"Public","body":"O"}}],"macros":[{"id":"method_missing(call)-macro","html_id":"method_missing(call)-macro","name":"method_missing","doc":null,"summary":null,"abstract":false,"args":[{"name":"call","doc":null,"default_value":"","external_name":"call","restriction":""}],"args_string":"(call)","location":{"filename":"src/proxy.cr","line_number":4,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/proxy.cr#L4"},"def":{"name":"method_missing","args":[{"name":"call","doc":null,"default_value":"","external_name":"call","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      self.instance.\n{{ call }}\n\n    \n"}}],"types":[]},{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Register","path":"Athena/DependencyInjection/Register.html","kind":"annotation","full_name":"Athena::DependencyInjection::Register","name":"Register","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/athena-dependency_injection.cr","line_number":582,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/athena-dependency_injection.cr#L582"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/DependencyInjection","kind":"module","full_name":"Athena::DependencyInjection","name":"DependencyInjection"},"doc":"Registers a service based on the type the annotation is applied to.\n\nThe type of the service affects how it behaves within the container.  When a `struct` service is retrieved or injected into a type, it will be a copy of the one in the SC (passed by value).\nThis means that changes made to it in one type, will _NOT_ be reflected in other types.  A `class` service on the other hand will be a reference to the one in the SC.  This allows it\nto share state between services.\n\n## Optional Arguments\n\nIn most cases, the annotation can be applied without additional arguments.  However, the annotation accepts a handful of optional arguments to fine tune how the service is registered.\n\n* `name : String`- The name of the service.  Should be unique.  Defaults to the type's FQN snake cased.\n* `public : Bool` - If the service should be directly accessible from the container.  Defaults to `false`.\n* `public_alias : Bool` - If a service should be directly accessible from the container via an alias.  Defaults to `false`.\n* `alias : T` - Injects `self` when this type is used as a type restriction.  See the Aliasing Services example for more information.\n* `tags : Array(String | NamedTuple(name: String, priority: Int32?))` - Tags that should be assigned to the service.  Defaults to an empty array.  See the [Tagging Services](./Register.html#tagging-services) example for more information.\n* `type : T` - The type of the service within the container.  Defaults to service's types.  See the [Customizing Service's Type](#customizing-services-type) section.\n* `factory : String | Tuple(T, String)` - Use a factory type/method to create the service.  See the [Factories](#factories) section.\n\n## Examples\n\n### Basic Usage\n\nThe simplest usage involves only applying the `ADI::Register` annotation to a type.  If the type does not have any arguments, then it is simply registered as a service as is.  If the type _does_ have arguments, then an attempt is made to register the service by automatically resolving dependencies based on type restrictions.\n\n```\n@[ADI::Register]\n# Register a service without any dependencies.\nstruct ShoutTransformer\n  def transform(value : String) : String\n    value.upcase\n  end\nend\n\n@[ADI::Register(public: true)]\n# The ShoutTransformer is injected based on the type restriction of the `transformer` argument.\nstruct SomeAPIClient\n  def initialize(@transformer : ShoutTransformer); end\n\n  def send(message : String)\n    message = @transformer.transform message\n\n    # ...\n  end\nend\n\nADI.container.some_api_client.send \"foo\" # => FOO\n```\n\n### Aliasing Services\n\nAn important part of DI is building against interfaces as opposed to concrete types.  This allows a type to depend upon abstractions rather than a specific implementation of the interface.\nOr in other words, prevents a singular implementation from being tightly coupled with another type.\n\nWe can use the `alias` argument when registering a service to tell the container that it should inject this service when a type restriction for the aliased service is found.\n\n```\n# Define an interface for our services to use.\nmodule TransformerInterface\n  abstract def transform(value : String) : String\nend\n\n@[ADI::Register(alias: TransformerInterface)]\n# Alias the `TransformerInterface` to this service.\nstruct ShoutTransformer\n  include TransformerInterface\n\n  def transform(value : String) : String\n    value.upcase\n  end\nend\n\n@[ADI::Register]\n# Define another transformer type.\nstruct ReverseTransformer\n  include TransformerInterface\n\n  def transform(value : String) : String\n    value.reverse\n  end\nend\n\n@[ADI::Register(public: true)]\n# The `ShoutTransformer` is injected because the `TransformerInterface` is aliased to the `ShoutTransformer`.\nstruct SomeAPIClient\n  def initialize(@transformer : TransformerInterface); end\n\n  def send(message : String)\n    message = @transformer.transform message\n\n    # ...\n  end\nend\n\nADI.container.some_api_client.send \"foo\" # => FOO\n```\n\nAny service that uses `TransformerInterface` as a dependency type restriction will get the `ShoutTransformer`.\nHowever, it is also possible to use a specific implementation while still building against the interface.  The name of the constructor argument is used in part to resolve the dependency.\n\n```\n@[ADI::Register(public: true)]\n# The `ReverseTransformer` is injected because the constructor argument's name matches the service name of `ReverseTransformer`.\nstruct SomeAPIClient\n  def initialize(reverse_transformer : TransformerInterface)\n    @transformer = reverse_transformer\n  end\n\n  def send(message : String)\n    message = @transformer.transform message\n\n    # ...\n  end\nend\n\nADI.container.some_api_client.send \"foo\" # => oof\n```\n\n### Scalar Arguments\n\nThe auto registration logic as shown in previous examples only works on service dependencies.  Scalar arguments, such as Arrays, Strings, NamedTuples, etc, must be defined manually.\nThis is achieved by using the argument's name prefixed with a `_` symbol as named arguments within the annotation.\n\n```\n@[ADI::Register(_shell: ENV[\"SHELL\"], _config: {id: 12_i64, active: true}, public: true)]\nstruct ScalarClient\n  def initialize(@shell : String, @config : NamedTuple(id: Int64, active: Bool)); end\nend\n\nADI.container.scalar_client # => ScalarClient(@config={id: 12, active: true}, @shell=\"/bin/bash\")\n```\nArrays can also include references to services by prefixing the name of the service with an `@` symbol.\n\n```\nmodule Interface; end\n\n@[ADI::Register]\nstruct One\n  include Interface\nend\n\n@[ADI::Register]\nstruct Two\n  include Interface\nend\n\n@[ADI::Register]\nstruct Three\n  include Interface\nend\n\n@[ADI::Register(_services: [\"@one\", \"@three\"], public: true)]\nstruct ArrayClient\n  def initialize(@services : Array(Interface)); end\nend\n\nADI.container.array_client # => ArrayClient(@services=[One(), Three()])\n```\n\nWhile scalar arguments cannot be auto registered by default, the `Athena::DependencyInjection.bind` macro can be used to support it.  For example: `ADI.bind shell, \"bash\"`.\nThis would now inject the string `\"bash\"` whenever an argument named `shell` is encountered.\n\n### Tagging Services\n\nServices can also be tagged.  Service tags allows another service to have all services with a specific tag injected as a dependency.\nA tag consists of a name, and additional metadata related to the tag.\nCurrently the only supported metadata value is `priority`, which controls the order in which the services are injected; the higher the priority\nthe sooner in the array it would be.  In the future support for custom tag metadata will be implemented.\n\nThe `Athena::DependencyInjection.auto_configure` macro may also be used to make working with tags easier.\n\n```\nPARTNER_TAG = \"partner\"\n\n@[ADI::Register(_id: 1, name: \"google\", tags: [{name: PARTNER_TAG, priority: 5}])]\n@[ADI::Register(_id: 2, name: \"facebook\", tags: [PARTNER_TAG])]\n@[ADI::Register(_id: 3, name: \"yahoo\", tags: [{name: \"partner\", priority: 10}])]\n@[ADI::Register(_id: 4, name: \"microsoft\", tags: [PARTNER_TAG])]\n# Register multiple services based on the same type.  Each service must give define a unique name.\nrecord FeedPartner, id : Int32\n\n@[ADI::Register(_services: \"!partner\", public: true)]\n# Inject all services with the `\"partner\"` tag into `self`.\nclass PartnerClient\n  def initialize(@services : Array(FeedPartner)); end\nend\n\nADI.container.partner_client # =>\n# #<PartnerClient:0x7f43c0a1ae60\n#  @services=\n#   [FeedPartner(@id=3, @name=\"Yahoo\"),\n#    FeedPartner(@id=1, @name=\"Google\"),\n#    FeedPartner(@id=2, @name=\"Facebook\"),\n#    FeedPartner(@id=4, @name=\"Microsoft\")]>\n```\n\nWhile tagged services cannot be injected automatically by default, the `Athena::DependencyInjection.bind` macro can be used to support it.  For example: `ADI.bind partners, \"!partner\"`.\nThis would now inject all services with the `partner` tagged when an argument named `partners` is encountered.\nA type restriction can also be added to the binding to allow reusing the name.  See the documentation for `Athena::DependencyInjection.bind` for an example.\n\n### Service Proxies\n\nIn some cases, it may be a bit \"heavy\" to instantiate a service that may only be used occasionally.\nTo solve this, a proxy of the service could be injected instead.\nThe instantiation of proxied services are deferred until a method is called on it.\n\nA service is proxied by changing the type signature of the service to be of the `ADI::Proxy(T)` type, where `T` is the service to be proxied.\n\n```\n@[ADI::Register]\nclass ServiceTwo\n  getter value = 123\n\n  def initialize\n    pp \"new s2\"\n  end\nend\n\n@[ADI::Register(public: true)]\nclass ServiceOne\n  getter service_two : ADI::Proxy(ServiceTwo)\n\n  # Tells `ADI` that a proxy of `ServiceTwo` should be injected.\n  def initialize(@service_two : ADI::Proxy(ServiceTwo))\n    pp \"new s1\"\n  end\n\n  def run\n    # At this point service_two hasn't been initialized yet.\n    pp \"before value\"\n\n    # First method interaction with the proxy instantiates the service and forwards the method to it.\n    pp @service_two.value\n  end\nend\n\nADI.container.service_one.run\n# \"new s1\"\n# \"before value\"\n# \"new s2\"\n# 123\n```\n\n#### Tagged Services Proxies\n\nTagged services may also be injected as an array of proxy objects.\nThis can be useful as an easy way to manage a collection of services where only one (or a small amount) will be used at a time.\n\n```\n@[ADI::Register(_services: \"!some_tag\")]\nclass SomeService\n  def initialize(@services : Array(ADI::Proxy(ServiceType)))\n  end\nend\n```\n\n#### Proxy Metadata\n\nThe `ADI::Proxy` object also exposes some metadata related to the proxied object; such as its name, type, and if it has been instantiated yet.\n\nFor example, using `ServiceTwo`:\n\n```\n# Assume this returns a `ADI::Proxy(ServiceTwo)`.\nproxy = ADI.container.service_two\n\nproxy.service_id    # => \"service_two\"\nproxy.service_type  # => ServiceTwo\nproxy.instantiated? # => false\nproxy.value         # => 123\nproxy.instantiated? # => true\n```\n\n### Parameters\n\nThe `Athena::Config` component provides a way to manage `ACF::Parameters`.\nIt is possible to inject these parameters directly into services in a type safe way.\n\nParameter injection utilizes a specially formatted string, similar to tagged services.\nThe parameter name should be a string starting and ending with a `%`, e.g. `\"%app.database.username%\"`.\nThe value within the `%` represents the \"path\" to the parameter from the `ACF::Parameters` base type.\n\nParameters may be supplied either via `Athena::DependencyInjection.bind` or an explicit service argument.\n\n```\nstruct DatabaseConfig\n  getter username : String = \"USERNAME\"\nend\n\nstruct AppConfig\n  getter name : String = \"My App\"\n  getter database : DatabaseConfig = DatabaseConfig.new\nend\n\nclass Athena::Config::Parameters\n  getter app : AppConfig = AppConfig.new\nend\n\nADI.bind db_username, \"%app.database.username%\"\n\n@[ADI::Register(_app_name: \"%app.name%\", public: true)]\nrecord SomeService, app_name : String, db_username : String\n\nservice = ADI.container.some_service\nservice.app_name    # => \"My App\"\nservice.db_username # => \"USERNAME\"\n```\n\n### Optional Services\n\nServices defined with a nillable type restriction are considered to be optional.  If no service could be resolved from the type, then `nil` is injected instead.\nSimilarly, if the argument has a default value, that value would be used instead.\n\n```\nstruct OptionalMissingService\nend\n\n@[ADI::Register]\nstruct OptionalExistingService\nend\n\n@[ADI::Register(public: true)]\nclass OptionalClient\n  getter service_missing, service_existing, service_default\n\n  def initialize(\n    @service_missing : OptionalMissingService?,\n    @service_existing : OptionalExistingService?,\n    @service_default : OptionalMissingService | Int32 | Nil = 12\n  ); end\nend\n\nADI.container.optional_client\n# #<OptionalClient:0x7fe7de7cdf40\n#  @service_default=12,\n#  @service_existing=OptionalExistingService(),\n#  @service_missing=nil>\n```\n\n### Generic Services\n\nGeneric arguments can be provided as positional arguments within the `ADI::Register` annotation.\n\nNOTE: Services based on generic types _MUST_ explicitly provide a name via the `name` field within the `ADI::Register` annotation\nsince there wouldn't be a way to tell them apart from the class name alone.\n\n```\n@[ADI::Register(Int32, Bool, name: \"int_service\", public: true)]\n@[ADI::Register(Float64, Bool, name: \"float_service\", public: true)]\nstruct GenericService(T, B)\n  def type\n    {T, B}\n  end\nend\n\nADI.container.int_service.type   # => {Int32, Bool}\nADI.container.float_service.type # => {Float64, Bool}\n```\n\n### Factories\n\nIn some cases it may be necessary to use the [factory design pattern](https://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29)\nto handle creating an object as opposed to creating the object directly.  In this case the `factory` argument can be used.\n\nFactory methods are class methods defined on some type; either the service itself or a different type.\nArguments to the factory method are provided as they would if the service was being created directly.\nThis includes auto resolved service dependencies, and scalar underscore based arguments included within the `ADI::Register` annotation.\n\n#### Same Type\n\nA `String` `factory` value denotes the method name that should be called on the service itself to create the service.\n\n```\n# Calls `StringFactoryService.double` to create the service.\n@[ADI::Register(_value: 10, public: true, factory: \"double\")]\nclass StringFactoryService\n  getter value : Int32\n\n  def self.double(value : Int32) : self\n    new value * 2\n  end\n\n  def initialize(@value : Int32); end\nend\n\nADI.container.string_factory_service.value # => 20\n```\n\n#### Different Type\n\nA `Tuple` can also be provided as the `factory` value to allow using an external type's factory method to create the service.\nThe first item represents the factory type to use, and the second item represents the method that should be called.\n\n```\nclass TestFactory\n  def self.create_tuple_service(value : Int32) : TupleFactoryService\n    TupleFactoryService.new value * 3\n  end\nend\n\n# Calls `TestFactory.create_tuple_service` to create the service.\n@[ADI::Register(_value: 10, public: true, factory: {TestFactory, \"create_tuple_service\"})]\nclass TupleFactoryService\n  getter value : Int32\n\n  def initialize(@value : Int32); end\nend\n\nADI.container.tuple_factory_service.value # => 30\n```\n\n### Customizing Service's Type\n\nBy default when a service is registered, it is typed the same as the service, for example:\n\n```\n@[ADI::Register]\nclass MyService; end\n```\n\nThis service is essentially represented in the service container as `@my_service : MyService`.\nThis is usually fine for most services, however there are some cases where the service's type should not be the concrete implementation.\nAn example of this is if that service should be mockable in a test setting.  Mockable services should be typed to an interface that they implement\nin order to allow mock implementations to be used if needed.\n\n```\nmodule SomeInterface; end\n\n@[ADI::Register(type: SomeInterface)]\nclass MyService\n  include SomeInterface\nend\n```\n\nBy specifying the `type` as `SomeInterface`, this changes the services representation in the service container to `@my_service : SomeInterface`,\nthus allowing the exact implementation to be changed.  See `ADI::Spec::MockableServiceContainer` for more details.","summary":"<p>Registers a service based on the type the annotation is applied to.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/DependencyInjection/ServiceContainer","path":"Athena/DependencyInjection/ServiceContainer.html","kind":"class","full_name":"Athena::DependencyInjection::ServiceContainer","name":"ServiceContainer","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/service_container.cr","line_number":6,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/service_container.cr#L6"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Spec/MockableServiceContainer","kind":"class","full_name":"Athena::DependencyInjection::Spec::MockableServiceContainer","name":"MockableServiceContainer"}],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/DependencyInjection","kind":"module","full_name":"Athena::DependencyInjection","name":"DependencyInjection"},"doc":"Where the instantiated services live.\n\nIf a service is public, a getter based on the service's name as well as its type is defined.  Otherwise, services are only available via constructor DI.\n\nTODO: Reduce the amount of duplication when [this issue](https://github.com/crystal-lang/crystal/pull/9091) is resolved.","summary":"<p>Where the instantiated services live.</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":"Initializes the container.  Auto registering annotated services.","summary":"<p>Initializes the container.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/service_container.cr","line_number":7,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/service_container.cr#L7"},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Spec","path":"Athena/DependencyInjection/Spec.html","kind":"module","full_name":"Athena::DependencyInjection::Spec","name":"Spec","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/spec.cr","line_number":11,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/spec.cr#L11"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/DependencyInjection","kind":"module","full_name":"Athena::DependencyInjection","name":"DependencyInjection"},"doc":"A set of testing utilities/types to aid in testing `Athena::DependencyInjection` related types.\n\n### Getting Started\n\nRequire this module in your `spec_helper.cr` file.\n\n```\n# This also requires \"spec\".\nrequire \"athena-dependency_injection/spec\"\n```","summary":"<p>A set of testing utilities/types to aid in testing <code><a href=\"../../Athena/DependencyInjection.html\">Athena::DependencyInjection</a></code> related types.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Spec/MockableServiceContainer","path":"Athena/DependencyInjection/Spec/MockableServiceContainer.html","kind":"class","full_name":"Athena::DependencyInjection::Spec::MockableServiceContainer","name":"MockableServiceContainer","abstract":false,"superclass":{"html_id":"athena-dependency_injection/Athena/DependencyInjection/ServiceContainer","kind":"class","full_name":"Athena::DependencyInjection::ServiceContainer","name":"ServiceContainer"},"ancestors":[{"html_id":"athena-dependency_injection/Athena/DependencyInjection/ServiceContainer","kind":"class","full_name":"Athena::DependencyInjection::ServiceContainer","name":"ServiceContainer"},{"html_id":"athena-dependency_injection/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/spec.cr","line_number":109,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/src/spec.cr#L109"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/DependencyInjection/Spec","kind":"module","full_name":"Athena::DependencyInjection::Spec","name":"Spec"},"doc":"A mock implementation of `ADI::ServiceContainer` that be used within a testing context to allow for mocking out services without affecting the actual container outside of tests.\n\nAn example of this is when integration testing service based [ART::Controller](https://athena-framework.github.io/athena/Athena/Routing/Controller.html)s.\nService dependencies that interact with an external source, like a third party API or a database, should most likely be mocked out.\nHowever your other services should be left as is in order to get the most benefit from the test.\n\n## Mocking\n\nThe `ADI::ServiceContainer` is nothing more than a normal Crystal class with some instance variables and methods.\nAs such, mocking services is as easy as monkey patching `self` with the mocked versions, assuming of course they are of a compatible type.\n\nGiven Crystal's lack of a robust mocking shard, it isn't as straightforward as other languages.\nThe best way at the moment is either using inheritance or interfaces (modules) to manually create a concrete test class/struct;\nwith the latter option being preferred as it would work for both structs and classes.\n\nFor example, we can create a mock implementation of a type by extending it:\n```\nclass MockMyService < MyService\n  def get_value\n    # Can now just return a static expected value.\n    # Test properties/constructor(s) can also be added to make it a bit more generic.\n    1234\n  end\nend\n```\n\nBecause our mock extends `MyService`, it is a compatible type for anything typed as `MyService`.\n\nAnother way to handle mocking is via interfaces (modules).\n\n```\nmodule SomeInterface; end\n\nstruct MockMyService\n  include SomeInterface\nend\n```\n\nBecause our mock implements `SomeInterface`, it is a compatible type for anything typed as `SomeInterface`.\n\nNOTE: Service mocks do not need to registered as services themselves since they will need to be configured manually.\nNOTE: The `type` argument as part of the `ADI::Register` annotation can be used to set the type of a service within the container.\nSee `ADI::Register@customizing-services-type` for more details.\n\n### Dynamic Mocks\n\nA dynamic mock consists of adding a `setter` to `self` that allows setting the mocked service dynamically at runtime,\nwhile keeping the original up until if/when it is replaced.\n\n```\nclass ADI::Spec::MockableServiceContainer\n  # The setter should be nilable as they're lazily initialized within the container.\n  setter my_service : MyServiceInterface?\nend\n\n# ...\n\n# Now the `my_service` service can be replaced at runtime.\nmock_container.my_service = MockMyService.new\n\n# ...\n```\n\n### Global Mocks\n\nGlobal mocks totally replace the original service, i.e. always return the mocked service.\n\n```\nclass ADI::Spec::MockableServiceContainer\n  # Global mocks should use the block based `getter` macro.\n  getter my_service : MyServiceInterface { MockMyService.new }\nend\n\n# `MockMyService` will now be injected across the board when using `self`.\n# ...\n```\n\n### Hybrid Mocks\n\nDynamic and Global mocking can also be combined to allow having a default mock, but allow overriding if/when needed.\nThis can be accomplished by adding both a getter and setter to `self.`\n\n```\nclass ADI::Spec::MockableServiceContainer\n  # Hybrid mocks should use the block based `property` macro.\n  property my_service : MyServiceInterface { DefaultMockService.new }\nend\n\n# ...\n\n# `DefaultMockService` will now be injected across the board by when using `self`.\n\n# But can still be replaced at runtime.\nmock_container.my_service = CustomMockService.new\n\n# ...\n```","summary":"<p>A mock implementation of <code><a href=\"../../../Athena/DependencyInjection/ServiceContainer.html\">ADI::ServiceContainer</a></code> that be used within a testing context to allow for mocking out services without affecting the actual container outside of tests.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]}]},{"html_id":"athena-dependency_injection/Athena/Spec","path":"Athena/Spec.html","kind":"module","full_name":"Athena::Spec","name":"Spec","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/athena-spec.cr","line_number":8,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/athena-spec.cr#L8"},{"filename":"lib/athena-spec/src/methods.cr","line_number":9,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/methods.cr#L9"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena","kind":"module","full_name":"Athena","name":"Athena"},"doc":"A set of common [Spec](https://crystal-lang.org/api/Spec.html) compliant testing utilities/types.","summary":"<p>A set of common <a href=\"https://crystal-lang.org/api/Spec.html\">Spec</a> compliant testing utilities/types.</p>","class_methods":[{"id":"run_all:Nil-class-method","html_id":"run_all:Nil-class-method","name":"run_all","doc":"Runs all `ASPEC::TestCase`s.\n\nIs equivalent to manually calling `.run` on each test case.","summary":"<p>Runs all <code><a href=\"../Athena/Spec/TestCase.html\">ASPEC::TestCase</a></code>s.</p>","abstract":false,"args":[],"args_string":" : Nil","args_html":" : Nil","location":{"filename":"lib/athena-spec/src/athena-spec.cr","line_number":12,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/athena-spec.cr#L12"},"def":{"name":"run_all","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"{% for unit_test in ASPEC::TestCase.all_subclasses.reject(&.abstract?) %}\n      {{ unit_test.id }}.run\n    {% end %}"}}],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"athena-dependency_injection/Athena/Spec/Methods","path":"Athena/Spec/Methods.html","kind":"module","full_name":"Athena::Spec::Methods","name":"Methods","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/methods.cr","line_number":9,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/methods.cr#L9"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[{"html_id":"athena-dependency_injection/Athena/Spec/Methods","kind":"module","full_name":"Athena::Spec::Methods","name":"Methods"}],"subclasses":[],"including_types":[{"html_id":"athena-dependency_injection/Athena/Spec/TestCase","kind":"struct","full_name":"Athena::Spec::TestCase","name":"TestCase"}],"namespace":{"html_id":"athena-dependency_injection/Athena/Spec","kind":"module","full_name":"Athena::Spec","name":"Spec"},"doc":"Namespace for common/helpful testing methods.\n\nThis module can be included into your `spec_helper` in order\nto allow your specs to use them all.  This module is also\nincluded into `ASPEC::TestCase` by default to allow using them\nwithin your unit tests as well.\n\nMay be reopened to add additional application specific helpers.","summary":"<p>Namespace for common/helpful testing methods.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"assert_error(file_path:String,message:String,*,prefix:String=&quot;spec/&quot;):Nil-instance-method","html_id":"assert_error(file_path:String,message:String,*,prefix:String=&quot;spec/&quot;):Nil-instance-method","name":"assert_error","doc":"Runs the Crystal program at the provided *file_path* and asserts it errors with the provided *message*.\nThe main purpose of this method is to test compile time errors.\n\nBy default, *file_path* is assumed to be within `spec/`, but can be customized via the *prefix* named argument.\n\nNOTE:\n\n```\n# ./spec/abstract_class.cr\nabstract class Foo; end\n\nFoo.new\n```\n\n```\n# ./spec/abstract_class_spec.cr\nrequire \"athena-spec\"\n\nASPEC::Methods.assert_error \"abstract_class.cr\", \"can't instantiate abstract class Foo\"\n```","summary":"<p>Runs the Crystal program at the provided <em>file_path</em> and asserts it errors with the provided <em>message</em>.</p>","abstract":false,"args":[{"name":"file_path","doc":null,"default_value":"","external_name":"file_path","restriction":"String"},{"name":"message","doc":null,"default_value":"","external_name":"message","restriction":"String"},{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"prefix","doc":null,"default_value":"\"spec/\"","external_name":"prefix","restriction":"String"}],"args_string":"(file_path : String, message : String, *, prefix : String = <span class=\"s\">&quot;spec/&quot;</span>) : Nil","args_html":"(file_path : String, message : String, *, prefix : String = <span class=\"s\">&quot;spec/&quot;</span>) : Nil","location":{"filename":"lib/athena-spec/src/methods.cr","line_number":32,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/methods.cr#L32"},"def":{"name":"assert_error","args":[{"name":"file_path","doc":null,"default_value":"","external_name":"file_path","restriction":"String"},{"name":"message","doc":null,"default_value":"","external_name":"message","restriction":"String"},{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"prefix","doc":null,"default_value":"\"spec/\"","external_name":"prefix","restriction":"String"}],"double_splat":null,"splat_index":2,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"buffer = IO::Memory.new\nresult = Process.run(\"crystal\", [\"run\", \"--no-color\", \"--no-codegen\", \"#{prefix}#{file_path}\"], error: buffer)\nif result.success?\n  fail(buffer.to_s)\nend\nbuffer.to_s.should(contain(message))\nbuffer.close\n"}},{"id":"run_executable(path:String,args:Array(String)=[]ofString,&:String,String,Process::Status->):Nil-instance-method","html_id":"run_executable(path:String,args:Array(String)=[]ofString,&:String,String,Process::Status->):Nil-instance-method","name":"run_executable","doc":"Runs the executable at the given *path*, optionally with the provided *args*.\n\nThe standard output, error output, and status of the execution are yielded.\n\n```\nrequire \"athena-spec\"\n\nASPEC::Methods.run_executable \"/usr/bin/ls\" do |output, error, status|\n  output # => \"docs\\n\" + \"LICENSE\\n\" + \"README.md\\n\" + \"shard.yml\\n\" + \"spec\\n\" + \"src\\n\"\n  error  # => \"\"\n  status # => #<Process::Status:0x7f7bc9befb70 @exit_status=0>\nend\n```","summary":"<p>Runs the executable at the given <em>path</em>, optionally with the provided <em>args</em>.</p>","abstract":false,"args":[{"name":"path","doc":null,"default_value":"","external_name":"path","restriction":"String"},{"name":"args","doc":null,"default_value":"[] of String","external_name":"args","restriction":"Array(String)"}],"args_string":"(path : String, args : Array(String) = <span class=\"o\">[]</span> <span class=\"k\">of</span> <span class=\"t\">String</span>, & : String, String, Process::Status -> ) : Nil","args_html":"(path : String, args : Array(String) = <span class=\"o\">[]</span> <span class=\"k\">of</span> <span class=\"t\">String</span>, & : String, String, Process::Status -> ) : Nil","location":{"filename":"lib/athena-spec/src/methods.cr","line_number":53,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/methods.cr#L53"},"def":{"name":"run_executable","args":[{"name":"path","doc":null,"default_value":"","external_name":"path","restriction":"String"},{"name":"args","doc":null,"default_value":"[] of String","external_name":"args","restriction":"Array(String)"}],"double_splat":null,"splat_index":null,"yields":3,"block_arg":{"name":"","doc":null,"default_value":"","external_name":"","restriction":"(String, String, Process::Status -> )"},"return_type":"Nil","visibility":"Public","body":"run_executable(path, IO::Memory.new, args) do |output_io, error_io, status|\n  yield output_io, error_io, status\nend"}},{"id":"run_executable(path:String,input:IO,args:Array(String)=[]ofString,&:String,String,Process::Status->):Nil-instance-method","html_id":"run_executable(path:String,input:IO,args:Array(String)=[]ofString,&:String,String,Process::Status->):Nil-instance-method","name":"run_executable","doc":"Runs the executable at the given *path*, with the given *input*, optionally with the provided *args*.\n\nThe standard output, error output, and status of the execution are yielded.\n\n```\nrequire \"athena-spec\"\n\ninput = IO::Memory.new %({\"id\":1})\n\nASPEC::Methods.run_executable \"jq\", input, [\".\", \"-c\"] do |output, error, status|\n  output # => \"{\\\"id\\\":1}\\n\"\n  error  # => \"\"\n  status # => #<Process::Status:0x7f26ec698b70 @exit_status=0>\nend\n\ninvalid_input = IO::Memory.new %({\"id\"1})\n\nASPEC::Methods.run_executable \"jq\", invalid_input, [\".\", \"-c\"] do |output, error, status|\n  output # => \"\"\n  error  # => \"parse error: Expected separator between values at line 1, column 7\\n\"\n  status # => #<Process::Status:0x7f0217496900 @exit_status=1024>\nend\n```","summary":"<p>Runs the executable at the given <em>path</em>, with the given <em>input</em>, optionally with the provided <em>args</em>.</p>","abstract":false,"args":[{"name":"path","doc":null,"default_value":"","external_name":"path","restriction":"String"},{"name":"input","doc":null,"default_value":"","external_name":"input","restriction":"IO"},{"name":"args","doc":null,"default_value":"[] of String","external_name":"args","restriction":"Array(String)"}],"args_string":"(path : String, input : IO, args : Array(String) = <span class=\"o\">[]</span> <span class=\"k\">of</span> <span class=\"t\">String</span>, & : String, String, Process::Status -> ) : Nil","args_html":"(path : String, input : IO, args : Array(String) = <span class=\"o\">[]</span> <span class=\"k\">of</span> <span class=\"t\">String</span>, & : String, String, Process::Status -> ) : Nil","location":{"filename":"lib/athena-spec/src/methods.cr","line_number":82,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/methods.cr#L82"},"def":{"name":"run_executable","args":[{"name":"path","doc":null,"default_value":"","external_name":"path","restriction":"String"},{"name":"input","doc":null,"default_value":"","external_name":"input","restriction":"IO"},{"name":"args","doc":null,"default_value":"[] of String","external_name":"args","restriction":"Array(String)"}],"double_splat":null,"splat_index":null,"yields":3,"block_arg":{"name":"","doc":null,"default_value":"","external_name":"","restriction":"(String, String, Process::Status -> )"},"return_type":"Nil","visibility":"Public","body":"output_io = IO::Memory.new\nerror_io = IO::Memory.new\nstatus = Process.run(path, args, error: error_io, output: output_io, input: input)\nyield output_io.to_s, error_io.to_s, status\n"}}],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Spec/TestCase","path":"Athena/Spec/TestCase.html","kind":"struct","full_name":"Athena::Spec::TestCase","name":"TestCase","abstract":true,"superclass":{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"athena-dependency_injection/Athena/Spec/Methods","kind":"module","full_name":"Athena::Spec::Methods","name":"Methods"},{"html_id":"athena-dependency_injection/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"athena-dependency_injection/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"athena-dependency_injection/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/athena-spec/src/test_case.cr","line_number":147,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L147"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[{"html_id":"athena-dependency_injection/Athena/Spec/Methods","kind":"module","full_name":"Athena::Spec::Methods","name":"Methods"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Spec","kind":"module","full_name":"Athena::Spec","name":"Spec"},"doc":"`ASPEC::TestCase` provides a [Spec](https://crystal-lang.org/api/Spec.html) compliant\nalternative DSL for creating unit and integration tests.  It allows structuring tests\nin a more OOP fashion, with the main benefits of reusability and extendability.\n\nThis type can be extended to share common testing logic with groups of similar types.\nAny tests defined within a parent will run for each child test case.\n`abstract def`, `super`, and other OOP features can be used as well to reduce duplication.\nSome additional features are also built in, such as the `DataProvider`.\n\nNOTE: This is _NOT_ a standalone testing framework.  Everything boils down to standard `describe`, `it`, and/or `pending` blocks.\n\nA test case consists of a `struct` inheriting from `self`, optionally with an `#initialize` method in order to\ninitialize the state that should be used for each test.\n\nA test is a method that starts with `test_`, where the method name is used as the description.\nFor example, `test_some_method_some_context` becomes `\"some method some context\"`.\nInternally each test method maps to an `it` block.\nAll of the stdlib's `Spec` assertions methods are available, in addition to\n[#pending!](https://crystal-lang.org/api/Spec/Methods.html#pending!%28msg=%22Cannotrunexample%22,file=__FILE__,line=__LINE__%29-instance-method) and\n[#fail](https://crystal-lang.org/api/Spec/Methods.html#fail%28msg,file=__FILE__,line=__LINE__%29-instance-method).\n\nA method may be focused by either prefixing the method name with an `f`, or applying the `Focus` annotation.\n\nA method may be marked pending by either prefixing the method name with a `p`, or applying the `Pending` annotation.\nInternally this maps to a `pending` block.\n\nTags may be applied to a method via the `Tags` annotation.\n\nThe `Tags`, `Focus`, and `Pending` annotations may also be applied to the test case type as well, with a similar affect.\n\n### Example\n\n```\n# Require the stdlib's spec module.\nrequire \"spec\"\n\n# Define a class to test.\nclass Calculator\n  def add(v1, v2)\n    v1 + v2\n  end\n\n  def subtract(v1, v2)\n    raise NotImplementedError.new \"TODO\"\n  end\nend\n\n# An example test case.\nstruct ExampleSpec < ASPEC::TestCase\n  @target : Calculator\n\n  # Initialize the test target along with any dependencies.\n  def initialize : Nil\n    @target = Calculator.new\n  end\n\n  # All of the stdlib's `Spec` methods can be used,\n  # plus any custom methods defined in `ASPEC::Methods`.\n  def test_add : Nil\n    @target.add(1, 2).should eq 3\n  end\n\n  # A pending test.\n  def ptest_substract : Nil\n    @target.subtract(10, 5).should eq 5\n  end\n\n  # Private/protected methods can be used to reduce duplication within the context of single test case.\n  private def helper_method\n    # ...\n  end\nend\n```\n\n## Inheritance\n\nInheritance can be used to build reusable test cases for groups of similar objects\n\n```\nabstract struct SomeTypeTestCase < ASPEC::TestCase\n  # Require children to define a method to get the object.\n  protected abstract def get_object : Calculator\n\n  # Test cases can use the abstract method for tests common to all test cases of this type.\n  def test_common : Nil\n    obj = self.get_object\n\n    # ...\n  end\nend\n\nstruct CalculatorTest < SomeTypeTestCase\n  protected def get_object : Calculator\n    Calculator.new\n  end\n\n  # Additional tests specific to this type.\n  def test_specific : Nil\n    # ...\n  end\nend\n```\n\n## Data Providers\n\nA `DataProvider` can be used to reduce duplication, see the corresponding annotation or more information.\n\n```\nstruct DataProviderTest < ASPEC::TestCase\n  # Data Providers allow reusing a test's multiple times with different input.\n  @[DataProvider(\"get_values\")]\n  def test_squares(value : Int32, expected : Int32) : Nil\n    (value ** 2).should eq expected\n  end\n\n  # Returns a hash where the key represents the name of the test,\n  # and the value is a Tuple of data that should be provided to the test.\n  def get_values : Hash\n    {\n      \"two\"   => {2, 4},\n      \"three\" => {3, 9},\n    }\n  end\nend\n```\n\n```\n# Run all the test cases\nASPEC.run_all # =>\n# ExampleSpec\n#   add\n#   subtract\n#   a custom method name\n# CalculatorTest\n#   common\n#   specific\n# DataProviderTest\n#   squares two\n#   squares three\n#\n# Pending:\n# ExampleSpec subtract\n#\n# Finished in 172 microseconds\n# 7 examples, 0 failures, 0 errors, 1 pending\n```","summary":"<p><code><a href=\"../../Athena/Spec/TestCase.html\">ASPEC::TestCase</a></code> provides a <a href=\"https://crystal-lang.org/api/Spec.html\">Spec</a> compliant alternative DSL for creating unit and integration tests.</p>","class_methods":[{"id":"run:Nil-class-method","html_id":"run:Nil-class-method","name":"run","doc":"Runs the tests contained within `self`.\n\nSee `Athena::Spec.run_all` to run all test cases.","summary":"<p>Runs the tests contained within <code>self</code>.</p>","abstract":false,"args":[],"args_string":" : Nil","args_html":" : Nil","location":{"filename":"lib/athena-spec/src/test_case.cr","line_number":253,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L253"},"def":{"name":"run","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"instance = new\n{% if true %}\n      {{ !(!(@type.annotation(Pending))) ? \"pending\".id : \"describe\".id }} {{ @type.name.stringify }}, focus: {{ !(!(@type.annotation(Focus))) }}{% if (tags = @type.annotation(Tags)) %}, tags: {{ tags.args }}{% end %} do\n        before_all do\n          instance.before_all\n        end\n\n        before_each do\n          instance.initialize\n        end\n\n        after_each do\n          instance.tear_down\n        end\n\n        after_all do\n          instance.after_all\n        end\n\n        {% methods = [] of Nil %}\n\n        {% for parent in @type.ancestors.select(&.<(TestCase)) %}\n          {% for method in parent.methods.select do |m|\n  m.name =~ (/^(?:f|p)?test_/)\nend %}\n            {% methods << method %}\n          {% end %}\n        {% end %}\n\n        {% for test in methods + @type.methods.select do |m|\n  m.name =~ (/^(?:f|p)?test_/)\nend %}\n          {% focus = (test.name.starts_with?(\"ftest_\")) || (!(!(test.annotation(Focus)))) %}\n          {% tags = (tags = test.annotation(Tags)) ? tags.args : nil %}\n          {% method = ((test.name.starts_with?(\"ptest_\")) || (!(!(test.annotation(Pending))))) ? \"pending\" : \"it\" %}\n          {% description = (test.name.stringify.gsub(/^(?:f|p)?test_/, \"\")).underscore.gsub(/_/, \" \") %}\n\n          {% if (test.annotations(DataProvider)).empty? %}\n            {{ method.id }} {{ description }}, file: {{ test.filename }}, line: {{ test.line_number }}, end_line: {{ test.end_line_number }}, focus: {{ focus }}, tags: {{ tags }} do\n              instance.{{ test.name.id }}\n            end\n          {% else %}\n            {% for data_provider in test.annotations(DataProvider) %}\n              {% data_provider_method_name = data_provider[0] || (data_provider.raise(\"One or more data provider for test '#{@type}##{test.name.id}' is mising its name.\")) %}\n              {% methods = @type.methods %}\n\n              {% for ancestor in @type.ancestors.select(&.<=(ASPEC::TestCase)) %}\n                {% methods += ancestor.methods %}\n              {% end %}\n\n              {% provider_method_return_type = (methods.find do |__arg2|\n  __arg2.name.stringify == data_provider_method_name\nend.return_type || (raise(\"Data provider '#{@type}##{data_provider_method_name.id}' must have a return type of Hash, NamedTuple, Array, or Tuple.\"))).resolve %}\n\n              {% if (provider_method_return_type == Hash) || (provider_method_return_type == NamedTuple) %}\n                instance.{{ data_provider_method_name.id }}.each do |name, args|\n                  {{ method.id }} \"#{{{ description }}} #{name}\", file: {{ test.filename }}, line: {{ test.line_number }}, end_line: {{ test.end_line_number }}, focus: {{ focus }}, tags: {{ tags }} do\n                    instance.{{ test.name.id }} *args\n                  end\n                end\n              {% else %}{% if (provider_method_return_type == Array) || (provider_method_return_type == Tuple) %}\n                instance.{{ data_provider_method_name.id }}.each_with_index do |args, idx|\n                  {{ method.id }} \"#{{{ description }}} #{idx}\", file: {{ test.filename }}, line: {{ test.line_number }}, end_line: {{ test.end_line_number }}, focus: {{ focus }}, tags: {{ tags }} do\n                    instance.{{ test.name.id }} *args\n                  end\n                end\n              {% else %}\n                {% provider_method.raise(\"Unsupported data provider return type: '#{provider_method.return_type}'\") %}\n              {% end %}{% end %}\n            {% end %}\n          {% end %}\n        {% end %}\n      end\n    {% end %}\n"}}],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":"Runs before each test.\n\nUsed to create the objects that will be used within the tests.\n\n```\nrequire \"spec\"\nrequire \"athena-spec\"\n\nstruct ExampleSpec < ASpec::TestCase\n  @value : Int32\n\n  def initialize : Nil\n    @value = 1\n  end\n\n  def test_one : Nil\n    @value += 1\n\n    @value # => 2\n  end\n\n  def test_two : Nil\n    @value # => 1\n  end\nend\n\nExampleSpec.run\n```","summary":"<p>Runs before each test.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"lib/athena-spec/src/test_case.cr","line_number":406,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L406"},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"after_all:Nil-instance-method","html_id":"after_all:Nil-instance-method","name":"after_all","doc":"Runs once after all tests within `self` have been executed.\n\n```\nrequire \"spec\"\nrequire \"athena-spec\"\n\nstruct ExampleSpec < ASPEC::TestCase\n  def after_all : Nil\n    puts \"This prints only once after anything else\"\n  end\n\n  def test_one : Nil\n    true.should be_true\n  end\n\n  def test_two : Nil\n    1.should eq 1\n  end\nend\n\nExampleSpec.run\n```","summary":"<p>Runs once after all tests within <code>self</code> have been executed.</p>","abstract":false,"args":[],"args_string":" : Nil","args_html":" : Nil","location":{"filename":"lib/athena-spec/src/test_case.cr","line_number":375,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L375"},"def":{"name":"after_all","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":""}},{"id":"before_all:Nil-instance-method","html_id":"before_all:Nil-instance-method","name":"before_all","doc":"Runs once before any tests within `self` have been executed.\n\nCan be used to initialize objects common to every test,\nbut that do not need to be reset before running each test.\n\n```\nrequire \"spec\"\nrequire \"athena-spec\"\n\nstruct ExampleSpec < ASPEC::TestCase\n  def before_all : Nil\n    puts \"This prints only once before anything else\"\n  end\n\n  def test_one : Nil\n    true.should be_true\n  end\n\n  def test_two : Nil\n    1.should eq 1\n  end\nend\n\nExampleSpec.run\n```","summary":"<p>Runs once before any tests within <code>self</code> have been executed.</p>","abstract":false,"args":[],"args_string":" : Nil","args_html":" : Nil","location":{"filename":"lib/athena-spec/src/test_case.cr","line_number":350,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L350"},"def":{"name":"before_all","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":""}},{"id":"tear_down:Nil-instance-method","html_id":"tear_down:Nil-instance-method","name":"tear_down","doc":"Runs after each test.\n\nCan be used to cleanup data in between tests, such as releasing a connection or closing a file.\n\n```\nrequire \"spec\"\nrequire \"athena-spec\"\n\nstruct ExampleSpec < ASPEC::TestCase\n  @file : File\n\n  def initialize : Nil\n    @file = File.new \"./foo.txt\", \"w\"\n  end\n\n  def tear_down : Nil\n    @file.close\n  end\n\n  def test_one : Nil\n    @file.path # => \"./foo.txt\"\n  end\nend\n\nExampleSpec.run\n```","summary":"<p>Runs after each test.</p>","abstract":false,"args":[],"args_string":" : Nil","args_html":" : Nil","location":{"filename":"lib/athena-spec/src/test_case.cr","line_number":435,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L435"},"def":{"name":"tear_down","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":""}}],"macros":[],"types":[{"html_id":"athena-dependency_injection/Athena/Spec/TestCase/DataProvider","path":"Athena/Spec/TestCase/DataProvider.html","kind":"annotation","full_name":"Athena::Spec::TestCase::DataProvider","name":"DataProvider","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/test_case.cr","line_number":248,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L248"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Spec/TestCase","kind":"struct","full_name":"Athena::Spec::TestCase","name":"TestCase"},"doc":"Tests can be defined with arbitrary arguments.  These arguments are provided by one or more `DataProvider`.\n\nA data provider is a method that returns either a `Hash`, `NamedTuple`, `Array`, or `Tuple`.\n\nNOTE: The method's return type must be set to one of those types.\n\nIf the return type is a `Hash` or `NamedTuple` then it is a keyed provider;\nthe key will be used as part of the description for each test.\n\nIf the return type is an `Array` or `Tuple` it is considered a keyless provider;\nthe index will be used as part of the description for each test.\n\nNOTE: In both cases the value must be a `Tuple`; the values should be an ordered list of the arguments you want to provide to the test.\n\nOne or more `DataProvider` annotations can be applied to a test\nwith a positional argument of the name of the providing methods.\nAn `it` block will be defined for each \"set\" of data.\n\nData providers can be a very powerful tool when combined with inheritance and `abstract def`s.\nA parent test case could define all the testing logic, and child implementations only provide the data.\n\n### Example\n\n```\nrequire \"athena-spec\"\n\nstruct DataProviderTest < ASPEC::TestCase\n  @[DataProvider(\"get_values_hash\")]\n  @[DataProvider(\"get_values_named_tuple\")]\n  def test_squares(value : Int32, expected : Int32) : Nil\n    (value ** 2).should eq expected\n  end\n\n  # A keyed provider using a Hash.\n  def get_values_hash : Hash\n    {\n      \"two\"   => {2, 4},\n      \"three\" => {3, 9},\n    }\n  end\n\n  # A keyed provider using a NamedTuple.\n  def get_values_named_tuple : NamedTuple\n    {\n      four: {4, 16},\n      five: {5, 25},\n    }\n  end\n\n  @[DataProvider(\"get_values_array\")]\n  @[DataProvider(\"get_values_tuple\")]\n  def test_cubes(value : Int32, expected : Int32) : Nil\n    (value ** 3).should eq expected\n  end\n\n  # A keyless provider using an Array.\n  def get_values_array : Array\n    [\n      {2, 8},\n      {3, 27},\n    ]\n  end\n\n  # A keyless provider using a Tuple.\n  def get_values_tuple : Tuple\n    {\n      {4, 64},\n      {5, 125},\n    }\n  end\nend\n\nASPEC.run_all # =>\n# DataProviderTest\n#   squares two\n#   squares three\n#   squares four\n#   squares five\n#   cubes 0\n#   cubes 1\n#   cubes 0\n#   cubes 1\n```","summary":"<p>Tests can be defined with arbitrary arguments.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Spec/TestCase/Focus","path":"Athena/Spec/TestCase/Focus.html","kind":"annotation","full_name":"Athena::Spec::TestCase::Focus","name":"Focus","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/test_case.cr","line_number":158,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L158"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Spec/TestCase","kind":"struct","full_name":"Athena::Spec::TestCase","name":"TestCase"},"doc":"Focuses a specific test case (describe block) or method (it block).\n\nMaps to [Focusing Specs](https://crystal-lang.org/reference/guides/testing.html#focusing-on-a-group-of-specs) in the stdlib.","summary":"<p>Focuses a specific test case (describe block) or method (it block).</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Spec/TestCase/Pending","path":"Athena/Spec/TestCase/Pending.html","kind":"annotation","full_name":"Athena::Spec::TestCase::Pending","name":"Pending","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/test_case.cr","line_number":163,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L163"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Spec/TestCase","kind":"struct","full_name":"Athena::Spec::TestCase","name":"TestCase"},"doc":"Marks a specific test case (describe block) or method (it block) as `pending`.\n\nMaps to the stdlib's [#pending](https://crystal-lang.org/api/master/Spec/Methods.html#pending%28description=%22assert%22,file=__FILE__,line=__LINE__,end_line=__END_LINE__,focus:Bool=false,tags:String%7CEnumerable%28String%29%7CNil=nil,&%29-instance-method) method.","summary":"<p>Marks a specific test case (describe block) or method (it block) as <code>pending</code>.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"athena-dependency_injection/Athena/Spec/TestCase/Tags","path":"Athena/Spec/TestCase/Tags.html","kind":"annotation","full_name":"Athena::Spec::TestCase::Tags","name":"Tags","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"lib/athena-spec/src/test_case.cr","line_number":153,"url":"https://github.com/athena-framework/dependency-injection/blob/38ea4f122af6fba2138d527a5c93495ac7103389/lib/athena-spec/src/test_case.cr#L153"}],"repository_name":"athena-dependency_injection","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"athena-dependency_injection/Athena/Spec/TestCase","kind":"struct","full_name":"Athena::Spec::TestCase","name":"TestCase"},"doc":"Defines the tags tied to a specific test case (describe block) or method (it block).\n\nMaps to [Tagging Specs](https://crystal-lang.org/reference/guides/testing.html#tagging-specs) in the stdlib.","summary":"<p>Defines the tags tied to a specific test case (describe block) or method (it block).</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]}]}]}]}})